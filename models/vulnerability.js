let mapper = require('../helpers/mapper');
let reports = require('../models/reports');
let mongo = require('../helpers/mongo');
const dashboardLimit = require('config').mongo.limit.dashboardCharts;
let hasProperty = require('../helpers/general').hasProperty;
let Promise = require('bluebird');
let _ = require('lodash');
let config = require('config');
let historyModel = require('../models/history');
let MongoObjectId = require('mongodb').ObjectID;
const moment = require('moment');
const mongoose = require('mongoose');
let storageModel = require('../models/storage').storage();
let models = require('../db_models');
const servicesHelper = require('../helpers/services');
const constantErrors = require('../helpers/constant-errors');
const scanModel = new mongoose.Schema({ scan_domain: String, targets: String, tenable_scan_id: Number });
const vulnModel = new mongoose.Schema({ name: String, severity: Number, port: String, count: Number });
const reportsModel = new mongoose.Schema({ utc_time: String, report_type: String, scan_id: Number, vulnerabilities: [{ type: mongoose.Schema.ObjectId, ref: 'vulnerabilities' }] });

const [vulnerabilityUpdateLimit, vulnerabilityInsertLimit] = [2000, 5000];
const severityVPRMapping = config.vprBySeverity;

const SECURITY_EXCEPTION = 'security_exception';
let mapTenable = {};
let severities = {};
let vulnerability;
let accessibleSlugs = [];

// Set the types for vulnerabilities
const vulnerabilityTypeProposedClosed = 'proposed_close_date';
const vulnerabilityTypeProposedClosedConfirmed = 'proposed_close_confirmed';
const vulnerabilityTypeProposedClosedResume = 'proposed_close_resume';
const vulnerabilityTypeFalsePositive = 'false_positive';
const vulnerabilityTypeFalsePositivePending = 'false_positive_pending';
const vulnerabilityTypeFalsePositiveRejected = 'false_positive_rejected';
const vulnerabilityTypeSecurityException = 'security_exception';
const vulnerabilityTypeSecurityExceptionPending = 'security_exception_pending';
const vulnerabilityTypeSecurityExceptionRejected = 'security_exception_rejected';

/**
     * Builds a vulnerability query for use within this function
     * @param {Number} organisationId - ID for the organisation to query
     * @param {Object} queryParameters - Additional query parameters to be added
     * @param {Boolean} unWind - if true aggregate will apply unwind on data
     * @returns {Promise}
     */
function buildVulnerabilityQuery(queryOrganisationId, queryParameters, unWind) {
  let collectionPromise = mongo.collection(queryOrganisationId,
    config.mongo.tables.vulnerabilities);
  return collectionPromise.then((vulnerabilityCollection) => {
    if (vulnerabilityCollection) {
      let aggregationQuery = [];
      let project = {
        $project:
        {
          _id: 1,
          tenable_scan_id: 1,
          tenable_host_id: 1,
          target: 1,
          tenable_plugin_id: 1,
          name: 1,
          severity: 1,
          port: 1,
          count: 1,
          description: 1,
          searchable_id: 1,
          'reports.report_name': 1,
          'reports._id': 1,
          history: 1
        }
      };
      let lookup = {
        $lookup: {
          from: config.mongo.tables.reports,
          localField: '_id',
          foreignField: 'vulnerabilities',
          as: 'reports'
        }
      };

      if (unWind) {
        aggregationQuery = [lookup,
          { $unwind: '$reports' },
          {
            $match: queryParameters
          },
          project
        ];
      } else {
        aggregationQuery = [lookup,
          {
            $match: queryParameters
          },
          project
        ];
      }
      return vulnerabilityCollection.aggregate(aggregationQuery);
    } else {
      return null;
    }
  }).catch((err) => {
    console.log(err);
  });
}

this.buildVulnerabilityQuery = buildVulnerabilityQuery;

/**
 * Get all pending vulnerabilities for the given organisation
 * @param {Number} organisationId - ID of the organisation to get the vulnerabilities for
 * @param {String} historyType - History action code if we want to filter (`SE`, `FP`)
 * @param {Number} reportId - ID of the report if we want to filter by that
 * @return {Object} Error on failure or Promise object of vulnerabilities on success
 */
function getPendingForOrganisation(organisationId, historyType = null, reportId = null) {
  let actionType;
  let vulnerabilities = null;

  const query = {
    $and: [{ 'history.status': historyModel.statuses.pending }]
  };

  // Filter by history type
  if (historyType !== null) {
    if (historyType === 'SE') {
      actionType = historyModel.historyAction.actionSecurityException;
    } else if (historyType === 'FP') {
      actionType = historyModel.historyAction.actionFalsePositive;
    } else if (historyType === 'PCD') {
      actionType = historyModel.historyAction.actionProposedCloseDate;
    }
    query.$and.push({ 'history.action': actionType });
  }

  // Filter by report ID
  if (reportId !== null) {
    query.$and.push({ 'reports._id': new MongoObjectId(reportId) });
  }

  vulnerabilities = buildVulnerabilityQuery(organisationId, query, true);
  let historyObject = {};

  let vulPromise = new Promise(function (resolve, reject) {
    if (vulnerabilities) {
      vulnerabilities.then((cursor) => {
        if (cursor) {
          cursor.toArray((error, response) => {
            if (error) {
              reject(error);
            } else {
              _.each(response, function (pendingVulnerability) {
                _.each(pendingVulnerability.history, function (historyItem) {
                  if (historyItem.status === historyModel.statuses.pending) {
                    delete historyItem.previous_values;
                    delete historyItem.new_values;
                    historyObject = historyItem;
                  }
                  pendingVulnerability.history = historyObject;
                });
              });
              resolve(response);
            }
          });
        } else {
          resolve(null);
        }
      }).catch((err) => {
        console.log(err);
      });
    } else {
      resolve(null);
    }
  });

  return vulPromise;
}


/**
   * Sort vulnerability object history by asc or desc
   * @param {Object} vulnerabilityObject - Vulnerability object
   * @param {Number} sorting - 0 for descending, 1 for ascending. Defaults to decending
   * @return {Object} - Provided vulnerability object with sorted history items
   */
const sortVulnerabilityHistory = (vulnerabilityObject, sorting = 0) => {
  let sortedHistory;
  let vulnerabilityToSort = vulnerabilityObject;

  // Sorting history items to order by last modification date and time
  if (Object.prototype.hasOwnProperty.call(vulnerabilityToSort, 'history')) {
    if (sorting === 1) {
      sortedHistory = _.sortBy(vulnerabilityToSort.history);
    } else {
      sortedHistory = _.sortBy(vulnerabilityToSort.history).reverse();
    }
    vulnerabilityToSort.history = sortedHistory;
  }

  return vulnerabilityToSort;
};

/**
  * Remove security exception object whose end date got expired
  * @param {Object} vulnerabilityObject - Vulnerability object
  * @return {Object} - Provided vulnerability object after expired security exception items got removed
*/
const removeExpiredSecurityException = (vulnerabilityObject) => {
  if (vulnerabilityObject && vulnerabilityObject.security_exception) {
    const now = moment();
    const endDate = moment(vulnerabilityObject.security_exception.end_date);

    if (now.toDate() > endDate.toDate()) {
      delete vulnerabilityObject.security_exception;
    }
  }

  return vulnerabilityObject;
};

/**
 * Calculate & update VEP & VPR fields in vulnerability object
 * @param {Object} vulnerability - Vulnerability object
 * @returns {Object} Updated vulnerability object
 */
const calculateVEPAndVPR = (vulnerability) => {
  if (!vulnerability.vpr) {
    vulnerability.vpr = 0;
  }

  if (vulnerability.severity > 0) {
    switch (true) {
      case parseInt(vulnerability.vpr) <= 0 && parseInt(vulnerability.cvssv2) > 0 && vulnerability.isExploit.toString().toLowerCase() === 'no':
        vulnerability.vpr = vulnerability.cvssv2;
        break;
      case parseInt(vulnerability.vpr) <= 0 && parseInt(vulnerability.cvssv2) > 0 && vulnerability.isExploit.toString().toLowerCase() !== 'no':
        vulnerability.vpr = (eval(vulnerability.cvssv2) + 9.9) / 2;
        break;
      case parseInt(vulnerability.vpr) <= 0 && parseInt(vulnerability.cvssv2) <= 0:
        vulnerability.vpr = severityVPRMapping[vulnerability.severity];
        break;
    }
  }

  vulnerability.vep = eval(vulnerability.acr) * eval(vulnerability.vpr);
  return vulnerability;
};

/**
 * Creates vulnerability Model for Business Logic.
 */
vulnerability = () => {
  // Array of fields to be mapped when responding to an API
  let mapApi = {
    _id: 'id',
    name: 'name',
    severity: 'severity',
    count: 'count',
    false_positive: 'false_positive',
    security_exception: 'security_exception',
    proposed_close_date: 'proposed_close_date',
    ticket: 'ticket',
    target: 'target',
    description: 'description',
    solution: 'solution',
    synopsis: 'synopsis',
    cve_numbers: 'cve_numbers',
    location: 'location',
    history: 'history',
    see_also: "see_also",
    risk_factor: "risk_factor",
    cvss: "cvss",
    notes: 'notes',
    searchable_id: 'searchable_id',
    reports: 'reports',
    utc_time_created: 'utc_time_created',
    locked: 'locked',
    protocol: 'protocol',
    port: 'port',
    plugin_output: 'plugin_output',
    tenable_plugin_id: "tenable_plugin_id",
    portInfo: "portInfo"
  };

  let constants = {
    optionsGroupBy: {
      'target-location': {
        fieldName: 'target',
        apiWrapperName: 'targets'
      },
      severity: {
        fieldName: 'severity',
        apiWrapperName: 'severities'
      }
    }
  };

  this.constants = constants;

  mapTenable = {
    _id: 'id',
    tenable_scan_id: 'tenable_scan_id',
    host_id: 'tenable_host_id',
    ip: 'target',
    protocol: 'protocol',
    port: 'portInfo',
    cvssVector: 'cvss',
    cve: 'cve_numbers',
    port_protocol: "port",
    "pluginID": 'tenable_plugin_id',
    seeAlso: 'see_also_info',
    pluginName: 'name',
    synopsis: "synopsis",
    severity: 'severity',
    seeAlso: "see_also",
    count: 'count',
    description: 'description',
    solution: 'solution',
    riskFactor: 'risk_factor',
    false_positive: 'false_positive',
    security_exception: 'security_exception',
    proposed_close_date: 'proposed_close_date',
    ticket: 'ticket',
    "pluginText": "plugin_output"
  };

  // Fields that can be updated through API
  this.writableFields = [
    'false_positive',
    'security_exception',
    'proposed_close_date',
    'ticket',
    'actionsToMark',
    'severity',
    'description',
    'solution',
    'history',
    'notes'
  ];

  // Possible values for Priority
  severities = {
    0: 'Info',
    1: 'Low',
    2: 'Medium',
    3: 'High',
    4: 'Critical'
  };

  // Possible slugs for vm actions
  accessibleSlugs = [
    {
      slug: 'false_positive',
      access: 'write',
      isAction: true
    }, {
      slug: 'security_exception',
      access: 'write',
      isAction: true
    }, {
      slug: 'ticket',
      access: 'write',
      isAction: true
    }, {
      slug: 'proposed_close_date',
      access: 'write',
      isAction: true
    }
  ];

  this.severities = severities;
  this.mapApi = mapApi;
  this.accessibleSlugs = accessibleSlugs;

  // Fields specifying type of vulnerability
  this.typeFields = [
    vulnerabilityTypeFalsePositive,
    vulnerabilityTypeSecurityException,
    vulnerabilityTypeProposedClosed
  ];


  /**
   * Sorts the history of an array of vulnerabilities by their history dates
   * @param {Object} vulnerabilities - collection of Vulnerabilities
   * @param {Number} sorting - 0 for descending, 1 for ascending. Defaults to decending
   * @return {Object} - Provided vulnerability objects with sorted history items
   */
  this.sortVulnerabilitiesHistory = (vulnerabilities, sorting = 0) => _.map(vulnerabilities,
    vulnerabilityToSort => sortVulnerabilityHistory(vulnerabilityToSort, sorting));

  /**
   * Remove the expired security exception objects
   * @param {Object} vulnerabilities - collection of Vulnerabilities
   * @return {Object} - Provided vulnerability objects after expired security exception items got removed
   */
  this.removeExpiredException = (vulnerabilities) => _.map(vulnerabilities,
    vulnerabilityObject => removeExpiredSecurityException(vulnerabilityObject));

  /**
  * Inserts a new scan report and vulnerabilities for that report
  * @param {Number} organisationId - Unique ID of the organisation
  * @param {Object} data - data is a collection of vulnerability
  * @return {Array} - Array of updated or inserted vulnerability IDs
  */
  this.syncVulnerabilities = (organisationId, data) => {

    /**
     * 
     * @param {Number} organisationId - Unique ID of the organisation
     * @param {Object[]} newVulnerabilities - Collection of new vulnerabilities
     * @returns {Object[]} List of vulnerability ids
     */
    const insertNewVulnerabilities = (organisationId, newVulnerabilities, index = 0, length = vulnerabilityInsertLimit, insertedIds = []) => {
      try {
        length = length > newVulnerabilities.length ? newVulnerabilities.length : length;
        let vulnerabilityList = newVulnerabilities.slice(index, length);
        return mongo.insert(organisationId, config.mongo.tables.vulnerabilities, vulnerabilityList).then((insertedDoc) => {
          if (!(insertedDoc && insertedDoc.insertedIds && insertedDoc.insertedIds.length > 0)) {
            return Promise.reject('Failed to insert vulnerabilities');
          }
          insertedDoc.insertedIds.forEach((id) => {
            insertedIds.push(id);
          });
          if (insertedIds.length === length) {
            let remainingList = newVulnerabilities.length - length;
            if (remainingList <= 0) {
              return Promise.resolve(insertedIds);
            } else {
              remainingList = remainingList > vulnerabilityInsertLimit ? vulnerabilityInsertLimit : remainingList;
              return insertNewVulnerabilities(organisationId, newVulnerabilities, length, remainingList + length, insertedIds).then();
            }
          }
        }).catch((mongoConnectionError) => {
          return Promise.reject(mongoConnectionError);
        });
      } catch (error) {
        return Promise.reject(error);
      }
    };

    /**
     * Update existing vulnerability, if not exists
     * @param {Number} organisationId - Unique ID of the organisation.
     * @param {Object} result - Data containing vulnerability information.
     */
    const updateExistingVulnerabilities = async (organisationId, existingVulnerabilities, index, length = vulnerabilityUpdateLimit, updatedRecords = []) => {
      length = length > existingVulnerabilities.length ? existingVulnerabilities.length : length;
      let vulnerabilityList = existingVulnerabilities.slice(index, length);
      let processedCount = index;
      let tempUpdatedRecords = [];
      await Promise.all(vulnerabilityList.map(async (result) => {
        let indexOfHistoryObject = -1;
        let query = { _id: result._id };
        let repeatingCount = result.count + 1;
        let fieldsToUpdate = {
          $set: {
            count: repeatingCount
          }
        };

        // PCD will be removed from a vulnerability if the next scan
        // fires off the same vulnerability
        if (result.hasOwnProperty('proposed_close_date')) {
          if (result.history && result.history.length > 0) {
            // find out the index of history object for PCD with status proposed
            indexOfHistoryObject = _.findIndex(result.history, {
              status: historyModel.statuses.proposed,
              action: 'proposed_close_date'
            });

            // Update the status of proposed PCD object to vulnerability_pcd_resume
            if (indexOfHistoryObject !== -1) {
              result.history[indexOfHistoryObject].status = null;
              result.history[indexOfHistoryObject].action = 'vulnerability_pcd_resume';
              result.history[indexOfHistoryObject].updated_by = null;
              result.history[indexOfHistoryObject].updated_at = new Date().toISOString();
              result.history[indexOfHistoryObject].reason = 'Vulnerability was fired again and therefore the PCD is no longer valid';
            }
          }
          delete result['proposed_close_date'];

          fieldsToUpdate = {
            $unset: {
              proposed_close_date: ''
            },
            $set: {
              count: repeatingCount,
              history: result.history
            }
          };
        }

        if (result.hasOwnProperty(SECURITY_EXCEPTION)) {
          if (result.history && result.history.length > 0) {
            let latestHistory = result.history[result.history.length - 1];

            if (latestHistory.status === 'approved' && latestHistory.action === SECURITY_EXCEPTION) {
              const currentDate = moment();

              if (result[SECURITY_EXCEPTION].end_date && currentDate.isAfter(moment(result[SECURITY_EXCEPTION].end_date))) {
                result.history.push({
                  status: null,
                  action: 'vulnerability_se_resume',
                  updated_by: null,
                  updated_at: new Date().toISOString(),
                  reason: constantErrors.vulnerabilities.resumeSecurityException
                });
                delete result[SECURITY_EXCEPTION];

                fieldsToUpdate = {
                  $unset: {
                    [SECURITY_EXCEPTION]: ''
                  },
                  $set: {
                    count: repeatingCount,
                    history: result.history
                  }
                };
              }
            }
          }
        }

        result = _.extend(result, fieldsToUpdate.$set);
        // update count of repeating vulnerability by one
        let updatedFields = { $set: result };
        if (fieldsToUpdate.$unset) {
          updatedFields.$unset = fieldsToUpdate.$unset;
        }

        try {
          let updatedVulnerability = await mongo.updateMany(organisationId, config.mongo.tables.vulnerabilities, query, updatedFields);
          if (!updatedVulnerability) {
            return Promise.reject('Failed to update vulnerabilities list');
          }
          tempUpdatedRecords.push(result._id);
          processedCount++;
          if (processedCount === length) {
            let remainingList = existingVulnerabilities.length - length;
            if (remainingList <= 0) {
              return setPCDConfirmed(existingVulnerabilities).then(() => {
                updatedRecords = updatedRecords.concat(tempUpdatedRecords);
                return Promise.resolve({});
              }).catch((mongoConnectionError) => {
                return Promise.reject(mongoConnectionError);
              });
            } else {
              remainingList = remainingList > vulnerabilityUpdateLimit ? vulnerabilityUpdateLimit : remainingList;
              updatedRecords = updatedRecords.concat(tempUpdatedRecords);
              return await updateExistingVulnerabilities(organisationId, existingVulnerabilities, length, remainingList + length, updatedRecords);
            }
          }
        } catch (error) {
          return Promise.reject(error);
        }
      }));

      return updatedRecords;
    };

    /**
     * Check vulnerability is exist in collection
     * @param {Array} vulnerabilityToFind - vulnerability data contains scan_id
     *, host_id and plugin_id to compare
     * @param {Array} vulnerabilityCollection - Collection of vulnerabilities
     * @return {Boolean} - True if vulnerability exists
     */
    const vulnerabilityExistsInCollection = (vulnerabilityToFind, vulnerabilityCollection) => {
      let exists = false;
      _.each(vulnerabilityCollection, (currentVulnerability) => {
        // Vulnerability to find
        const [toFindScanId, toFindHostId, toFindPluginId] = [vulnerabilityToFind.tenable_scan_id,
        vulnerabilityToFind.tenable_host_id, vulnerabilityToFind.tenable_plugin_id]

        // Current vulnerability
        const [collectionScanId, collectionHostId, collectionPluginId] = [
          currentVulnerability.tenable_scan_id, currentVulnerability.tenable_host_id,
          currentVulnerability.tenable_plugin_id]

        if (toFindScanId === collectionScanId && toFindHostId === collectionHostId
          && toFindPluginId === collectionPluginId) {
          exists = true;
        }
      });
      return exists;
    };

    const updatePCDStatus = (tenableVulnerabilities, dbVulnerabilities, index) => {
      let dbVulnerability = dbVulnerabilities && dbVulnerabilities[index] ? dbVulnerabilities[index] : null;
      let indexOfHistoryObject = -1;
      // Loop through all db vulnerabilities and check if it is still repeating
      if (dbVulnerability && dbVulnerability._id && !vulnerabilityExistsInCollection(dbVulnerability, tenableVulnerabilities)) {
        // If db vulnerability not found in Nessus vulnerability
        //  set the PCD confirmed field, so that it will invisible for customer
        let pcdUpdateField = { 'proposed_close_date.confirmed_closed': 1 };
        // Get the most recent history item and update the status to 'approved'
        indexOfHistoryObject = _.findIndex(dbVulnerability.history, {
          status: 'proposed',
          action: 'proposed_close_date'
        });

        if (indexOfHistoryObject !== -1) {
          // update the PCD object in history to approved
          pcdUpdateField['history._id'] = dbVulnerability.history[indexOfHistoryObject]._id;
          pcdUpdateField['history.$.status'] = historyModel.statuses.approved;
        }

        return mongo.updateMany(organisationId, config.mongo.tables.vulnerabilities, { _id: dbVulnerability._id }, { $set: pcdUpdateField }).then(() => {
          if (index < dbVulnerabilities.length - 1) {
            return updatePCDStatus(tenableVulnerabilities, dbVulnerabilities, index + 1).then();
          } else {
            return Promise.resolve({});
          }
        }).catch((mongoConnectionError) => {
          return Promise.reject(mongoConnectionError);
        });
      }
    };

    /**
      * Set vulnerabilities hidden for customer,
      * if same vulnerability not repeating and marked proposed_close_date
      * @param {Object} tenableVulnerabilities - vulnerabilities data
      * @return {Promise} - db Promise
      */
    const setPCDConfirmed = (tenableVulnerabilities) => {
      if (tenableVulnerabilities.length > 0) {
        // Making query to get vulnerabilities having proposed_close_date for scan
        let queryParameters = {
          $and: [{ tenable_scan_id: tenableVulnerabilities[0].tenable_scan_id },
          { proposed_close_date: { $exists: true } }]
        };
        // Get scan vulnerabilities having proposed_close_date
        return mongo.find(organisationId, config.mongo.tables.vulnerabilities, queryParameters).then((dbCursor) => {
          if (dbCursor) {
            return dbCursor.toArray().then((dbVulnerabilities) => {
              if (dbVulnerabilities && dbVulnerabilities.length > 0) {
                return updatePCDStatus(tenableVulnerabilities, dbVulnerabilities, 0).then(() => {
                  return Promise.resolve({});
                }).catch((mongoConnectionError) => {
                  return Promise.reject(mongoConnectionError);
                });
              } else {
                return Promise.resolve({});
              }
            });
          } else {
            return Promise.reject("Failed to update PCD status");
          }
        }).catch((mongoConnectionError) => {
          return Promise.reject(mongoConnectionError);
        });
      }
    };

    const updateVulnerabilityData = async (organisationId, existingVulnerabilities, finalVulnerabilityIds) => {
      try {
        await updateExistingVulnerabilities(organisationId, existingVulnerabilities, 0);

        return Promise.resolve(finalVulnerabilityIds);
      } catch (error) {
        return Promise.reject(error);
      }
    };

    return storageModel.get('vulnerability_count').then((vulnerabilityCount) => {
      let updatedVulnerabilityCount = 0;
      if (vulnerabilityCount !== null) {
        // initialize vulnerabilityCount in storage table
        updatedVulnerabilityCount = parseInt(vulnerabilityCount.storage_value, 10);
      }
      let [newVulnerabilities, vulnerabilityIPs, finalVulnerabilityIds, existingVulnerabilities] = [[], [], [], []];
      // generate & store searchable ids for all vulnerabilities
      _.each(data, function (vulnerabilityObject, index) {
        let searchableID = updatedVulnerabilityCount + index;
        searchableID += 1;
        vulnerabilityObject.searchable_id = searchableID + '';

        // check for the latest id
        if (index === data.length - 1) {
          updatedVulnerabilityCount = searchableID;
        }
      });

      let groupedQueryByIP = _.groupBy(data, 'ip');
      if (_.size(groupedQueryByIP) > 0) {
        for (const key in groupedQueryByIP) {
          vulnerabilityIPs.push({ target: key });
        }
      }

      // update vulnerability_count in database
      storageModel.set('vulnerability_count', updatedVulnerabilityCount);

      const vulnerabilityQuery = vulnerabilityIPs.length > 0 ? { $or: vulnerabilityIPs } : {};

      return mongo.find(organisationId, config.mongo.tables.vulnerabilities, vulnerabilityQuery).then((vulnerabilityCursor) => {
        if (vulnerabilityCursor) {
          return vulnerabilityCursor.toArray().then(async (vulnerabilityList) => {
            if (vulnerabilityList) {
              const groupedVulnerabilityByPluginId = _.groupBy(vulnerabilityList, 'tenable_plugin_id');
              data.forEach((vulnerabilityObject) => {
                const vulnerabilityListByPlugin = groupedVulnerabilityByPluginId[vulnerabilityObject.pluginID];
                let vulnerabilityIndex = vulnerabilityListByPlugin && vulnerabilityListByPlugin[0] ? _.findIndex(vulnerabilityListByPlugin, {
                  tenable_plugin_id: vulnerabilityObject['pluginID'],
                  target: vulnerabilityObject.ip,
                  portInfo: vulnerabilityObject.port,
                  protocol: vulnerabilityObject.protocol,
                  plugin_output: vulnerabilityObject['pluginText']
                }) : -1;

                vulnerabilityObject = mapper.renameFields(vulnerabilityObject, mapTenable);
                if (vulnerabilityObject.cvssV3BaseScore) {
                  vulnerabilityObject.cvssv2 = vulnerabilityObject.cvssV3BaseScore;
                }
                vulnerabilityObject = calculateVEPAndVPR(vulnerabilityObject);
                if (vulnerabilityIndex < 0) {
                  vulnerabilityObject.count = 0;
                  newVulnerabilities.push(vulnerabilityObject);
                } else {
                  let existingObject = vulnerabilityListByPlugin[vulnerabilityIndex];
                  finalVulnerabilityIds.push(existingObject._id);
                  existingObject = _.extend(existingObject, vulnerabilityObject);

                  existingVulnerabilities.push(existingObject);
                }
              });

              if (newVulnerabilities.length > 0) {
                return insertNewVulnerabilities(organisationId, newVulnerabilities).then(async (insertedIds) => {
                  finalVulnerabilityIds = finalVulnerabilityIds.concat(insertedIds);
                  if (existingVulnerabilities && existingVulnerabilities.length > 0) {
                    return await updateVulnerabilityData(organisationId, existingVulnerabilities, finalVulnerabilityIds);
                  } else {
                    return setPCDConfirmed(newVulnerabilities).then(() => {
                      return Promise.resolve(finalVulnerabilityIds);
                    }).catch((mongoConnectionError) => {
                      return Promise.reject(mongoConnectionError);
                    });
                  }
                }).catch((mongoConnectionError) => {
                  return Promise.reject(mongoConnectionError);
                });
              } else if (existingVulnerabilities && existingVulnerabilities.length > 0) {
                return await updateVulnerabilityData(organisationId, existingVulnerabilities, finalVulnerabilityIds);
              } else {
                return Promise.reject('Failed to update vulnerabilities');
              }
            } else {
              return Promise.reject('Mongo connection error');
            }
          }).catch((mongoConnectionError) => {
            return Promise.reject(mongoConnectionError);
          });
        } else {
          return Promise.reject('Mongo connection error');
        }
      }).catch((mongoConnectionError) => {
        return Promise.reject(mongoConnectionError);
      });
    });
  };

  /**
   * Gets all the vulnerabilities for this report
   * @param {Number} organisationId - Unique ID of the organisation
   * @param {Object} reportId - ID of the report to get the vulnerabilities for
   * @return {Cursor} - Mongo cursor to the vulnerabilities required (you can
   *  call `toArray()` on this, or add pagination etc.)
   */
  this.getByReportId = (organisationId, reportId, queryParameters = {}, groupBy = null, userType) =>
    // Get all the vulnerability IDs from the given report table
    reports.getById(organisationId, reportId).then((report) => {
      let collectionPromise;
      let vulnerabilityIds;
      let aggregateQueryParams;
      if (report) {
        vulnerabilityIds = report.vulnerabilities;
        queryParameters._id = { $in: vulnerabilityIds };

        // Filtering query to make sure, vulnerability
        // or vulnerabilities having "soft_deleted_at" will not visible to Customer
        aggregateQueryParams = mongo.filteredQueryByUserType(queryParameters, userType);
        // Get those vulnerabilities from Mongo!
        collectionPromise = mongo.collection(organisationId
          , config.mongo.tables.vulnerabilities);
        return collectionPromise.then((vulnerabilityCollection) => {
          if (vulnerabilityCollection) {
            let aggregationQuery = [{
              $match: aggregateQueryParams
            }];
            if (groupBy in constants.optionsGroupBy) {
              aggregationQuery.push({
                $group: {
                  _id: '$' +
                    constants.optionsGroupBy[groupBy].fieldName,
                  vulnerabilities: { $push: '$$ROOT' }
                }
              });
            }

            return vulnerabilityCollection.aggregate(aggregationQuery, { allowDiskUse: true });
          } else {
            return null;
          }
        });
      }
      return null;
    });

  /**
   * Takes a vulnerability and adds any plugin information (description and
   *  solution) to the object if there's nothing to override with
   * @param {Object} vulnerability - Vulnerability to alter and add plugin
   *  information to
   * @return {Object} - The updated vulnerability
   */
  this.appendPluginInformation = (vulnerabilityToUpdate) => {
    return new Promise(function (resolve) {
      if (Object.prototype.hasOwnProperty('description')) {
        vulnerabilityToUpdate.description = _.trim(vulnerabilityToUpdate.description);
      }

      if (Object.prototype.hasOwnProperty('solution')) {
        vulnerabilityToUpdate.solution = _.trim(vulnerabilityToUpdate.solution);
      }

      // Add the risk_factor
      if (Object.prototype.hasOwnProperty('risk_factor')) {
        vulnerabilityToUpdate.risk_factor = _.trim(vulnerabilityToUpdate.risk_factor);
      }

      resolve(vulnerabilityToUpdate);
    });
  };

  /**
    * Takes array of vulnerabilities and return count for each type of vulnerability
    * @param {Array} vulnerabilities - List of vulnerabilities
    * @return {Object} - Object with count of each vulnerability
    */
  this.getVulnerabilityTypesCount = (vulnerabilityIds, allVulnerabilties) => {
    let vulnerabilitiesCountObject = {};
    let infoCount = 0;
    let lowCount = 0;
    let mediumCount = 0;
    let highCount = 0;
    let criticalCount = 0;

    let severityKeys = Object.keys(severities);
    let severityKeysIntValues = severityKeys.map(Number);
    let vulnerabilityIdsAsString = vulnerabilityIds.map(String);
    _.each(allVulnerabilties, (currentVulnerability) => {
      if (vulnerabilityIdsAsString.indexOf(String(currentVulnerability._id)) > -1) {
        if (currentVulnerability.severity === severityKeysIntValues[0]) {
          infoCount += 1;
        } else if (currentVulnerability.severity === severityKeysIntValues[1]) {
          lowCount += 1;
        } else if (currentVulnerability.severity === severityKeysIntValues[2]) {
          mediumCount += 1;
        } else if (currentVulnerability.severity === severityKeysIntValues[3]) {
          highCount += 1;
        } else if (currentVulnerability.severity === severityKeysIntValues[4]) {
          criticalCount += 1;
        }
      }
    });

    vulnerabilitiesCountObject.info = infoCount;
    vulnerabilitiesCountObject.low = lowCount;
    vulnerabilitiesCountObject.medium = mediumCount;
    vulnerabilitiesCountObject.high = highCount;
    vulnerabilitiesCountObject.critical = criticalCount;

    return vulnerabilitiesCountObject;
  };

  /**
    * Takes array of vulnerabilities grouped by severity
    * & calculates count based on type of severity
    * @param {Array} vulnerabilitiesBySeverityArray - Vulnerabilities grouped by severity
    * @return {Object} - Object with count of vulnerabilities by severity
    */
  this.getSeverityCountForVulnerabilities = (vulnerabilitiesBySeverityArray) => {
    let objToSend = {};
    _.each(vulnerabilitiesBySeverityArray, (value, key) => {
      let valueForSeverity = severities[key].toLowerCase();
      objToSend[valueForSeverity] = value.length;
    });
    return objToSend;
  };

  this.getMinMaxForFields = (organisationId) => {
    // Get those vulnerabilities from Mongo!
    let collectionPromise = mongo.collection(organisationId, config.mongo.tables.vulnerabilities);
    return collectionPromise.then((vulnerabilityCollection) => {
      if (vulnerabilityCollection) {
        let aggregationQuery = [
          {
            $group:
            {
              _id: '$name',
              count: { $sum: 1 }
            }
          },
          { $sort: { count: -1 } }, { $limit: 1 }
        ];
        return vulnerabilityCollection.aggregate(aggregationQuery);
      } else {
        return null;
      }
    });
  };

  this.getPendingForOrganisation = getPendingForOrganisation;

  /**
    * @description add notes to the specific vulnerability object in mongo
    * @param {String} organisationId - Organisation ID
    * @param {Object} queryParams - criteria for adding notes to vulnerability
    * @param {Object} fieldsToSet - notes object to be added inside vulnerability
    * @return {Object} - Error on failure or Promise object of vulnerability on success
    */
  this.addNotesToVulnerability = (organisationId,
    queryParams, fieldsToSet) => {
    fieldsToSet.notes.id = new MongoObjectId();
    return mongo.upsertArray(organisationId, config.mongo.tables.vulnerabilities,
      queryParams, fieldsToSet);
  };

  /**
    * @description get notes for a specific vulnerability
    * @param {String} organisationId - Organisation ID
    * @param {Object} queryParams - criteria for retreriving vulnerability ID
    * @return {Object} - Error on failure or Promise object of vulnerability on success
    */
  this.getNotesForVulnerability = (organisationId, vulnerabilityId) => {
    let projection = { notes: 1 };
    let queryParams = { _id: new MongoObjectId(vulnerabilityId) };
    return mongo.findOne(organisationId, config.mongo.tables.vulnerabilities
      , queryParams, projection);
  };

  /**
    * @description Create a lock data according incoming params
    * @param {odject} [userInfo] - object, about person, that posted request
    * @param {Object} [now] - moment object, that represents current time (optional)
    * @return {Object} - data for lock property
    */
  this.createLockProperty = (userInfo, now = moment()) => {
    const willUnlock = now.clone().add(config.vulnerabilities.minutesToLock, 'minutes');

    return {
      lockedById: userInfo.id,
      lockedByName: userInfo.username,
      willUnlock: willUnlock.toDate()
    };
  };

  /**
    * @description Check is vulnerability locked according provided data
    * @param {Object} [locked] property from vulnerability
    * @param {number} [userId] - user id, that posted a request
    * @param {Object} [now] - moment object, that represents current time (optional)
    * @return {Bool} - locked status
    */
  this.isLocked = (locked, userId, now = moment().toDate()) => {
    if (!locked ||
      locked.lockedById === userId ||
      locked.willUnlock < now) {
      return false;
    }
    return true;
  };

  /**
    * @description Query and lock vulnerabilities according params
    * @param {number} [organisationId] - id of organisation
    * @param {String|String[]} [vulnerabilityIds] - vulnerability ID or array of ID's
    * @param {Object} [userInfo] - an information about person, that posted request
    * @return {Object} - Object promise
    */
  this.lockVulnerabilitiesByIds = (organisationId, vulnerabilityIds, userInfo) => {
    let vulnerabilityIdsArr = vulnerabilityIds;
    if (!_.isArray(vulnerabilityIds)) {
      vulnerabilityIdsArr = [vulnerabilityIds];
    }

    const vulnerabilityTable = config.mongo.tables.vulnerabilities;
    const now = moment();

    const queryParams = {
      $and: [
        { _id: { $in: mongo.convertIdsToMongoIds(vulnerabilityIdsArr) } },
        {
          $or: [
            { locked: { $exists: false } },
            { 'locked.lockedById': { $eq: userInfo.id } },
            { 'locked.willUnlock': { $lt: now.toDate() } }
          ]
        }
      ]
    };

    const updateObj = {
      $set: { locked: this.createLockProperty(userInfo, now) }
    };
    return mongo.updateMany(organisationId, vulnerabilityTable, queryParams, updateObj);
  };

  return this;
};


/**
 * @description Get vulnerabilities of provided report(s) Id for the given organisation
 * @param {Number} organisationId - ID of the organisation to get the vulnerabilities for
 * @param {Array} reportIds - Array of report Id's to get the vulnerabilities
 * @return {Object} Mongo cursor
 */
const getVulnerabiltiesByReports = (organisationId, reportIds, queryParameters = {}) => {
  const mongoReportIds = [];
  _.each(reportIds, (reportId) => {
    mongoReportIds.push(new MongoObjectId(reportId));
  });

  let aggregationQuery = [{
    $lookup: {
      from: config.mongo.tables.vulnerabilities,
      localField: 'vulnerabilities',
      foreignField: '_id',
      as: 'vulnerabilities'
    }
  },
  { $unwind: { path: "$vulnerabilities", "preserveNullAndEmptyArrays": true } }
  ];

  if (mongoReportIds.length > 0) {
    aggregationQuery.push({
      $match: {
        _id: { $in: mongoReportIds }
      }
    });
  }

  if (_.size(queryParameters) > 0) {
    aggregationQuery.push({
      $match: queryParameters
    });
  }

  return mongo.collection(organisationId, config.mongo.tables.reports)
    .then(reportCollection => {
      if (reportCollection) {
        return reportCollection.aggregate(aggregationQuery);
      } else {
        return null;
      }
    });
};

const getScanIdOfReports = (scanCollection) => {
  let scanIdQuery = [];

  if (scanCollection && scanCollection.length > 0) {
    scanCollection.forEach((scanObject) => {
      scanIdQuery.push({ scan_id: scanObject.tenable_scan_id });
    });
  }

  return scanIdQuery;
};

const getReportsForField = async (iterationCount, reportQuery, populate, db = {}, reports = [], skipCount = 0) => {
  try {
    db.model('vulnerabilities', vulnModel);
    let reportsList = await db.model('reports', reportsModel).find(reportQuery, 'utc_time report_type scan_id vulnerabilities').populate(populate).limit(dashboardLimit).skip(skipCount).lean();

    if (reportsList && reportsList.length > 0) {
      reports = reports.concat(reportsList);
    }

    iterationCount--;

    if (iterationCount > 0) {
      return await getReportsForField(iterationCount, reportQuery, populate, db, reports, reports.length)
    } else {
      return reports;
    }
  } catch (error) {
    throw error;
  }
};

/**
 * Get chart data from Mongo DB
 * @param {String} url - MOngo connection URL
 * @param {Object} scanqueryParameters - Object to be queried in scan collection
 * @param {Object} reportQuery - Object to be queried in report collection
 * @param {Object} populate - Object to be queried in vulnerability collection
 */
const getChartDataFromMongoDB = async (url, scanqueryParameters = {}, reportQuery = {}, populate = {}) => {
  try {
    let dbName = url.split('/');
    let db = mongoose.connection.useDb(dbName[dbName.length - 1]);
    let scans = await db.model('scans', scanModel).find(scanqueryParameters, 'scan_domain targets tenable_scan_id');

    reportQuery.$or = getScanIdOfReports(scans);

    let totalCount = await db.model('reports', reportsModel).countDocuments(reportQuery);
    let iterationCount = totalCount > dashboardLimit ? getIterationCount(totalCount) : 1;
    let reports = await getReportsForField(iterationCount, reportQuery, populate, db);

    return { scans, reports };
  } catch (error) {
    throw error;
  }
};

/**
 * @description Get vulnerabilities of provided report(s) Id for the given organisation
 * @param {String} url - Mongo connection URL
 * @param {Array} reportIds - Array of report Id's to get the vulnerabilities
 * @return {Object} Mongo cursor
 */
const getVulnerabiltiesForCharts = async (url, scanqueryParameters = {}, reportQueryParameters = {}, match = null) => {
  try {
    let reportQuery = { report_type: "finalised" };
    let populate = { path: "vulnerabilities", select: "name severity port count" };

    if (reportQueryParameters.fromDate) {
      reportQuery.utc_time = { $gte: reportQueryParameters.fromDate };
    }

    if (reportQueryParameters.toDate) {
      reportQuery.utc_time = { $lte: reportQueryParameters.toDate };
    }

    if (reportQueryParameters._id) {
      reportQuery._id = reportQueryParameters._id;
    }

    if (match) {
      populate.match = match;
    }

    return await getChartDataFromMongoDB(url, scanqueryParameters, reportQuery, populate);
  } catch (error) {
    throw error;
  }
};


/**
 * Gets the most recent history item for the given vulnerability
 * @param {Object} vulnerabilityToProcess The vulnerability to get the history item for
 * @returns {Object|null} Returns the history object or null if there is no history
 */
function getMostRecentHistoryItem(vulnerabilityToProcess) {
  if ((!hasProperty(vulnerabilityToProcess, 'history'))
    || (vulnerabilityToProcess.history.length === 0)) {
    return null;
  }

  const sortedVulnerability = sortVulnerabilityHistory(vulnerabilityToProcess);
  const mostRecentHistoryItem = sortedVulnerability.history[0];

  return mostRecentHistoryItem;
}

/**
 * Gets the current type of vulnerability
 * @param {Object} vulnerabilityToCheck The vulnerability we want to get the type for
 * @returns {String} Type of vulnerability
 */
function getVulnerabilityType(vulnerabilityToCheck) {
  // Check the main objects of the vulnerability first
  if (hasProperty(vulnerabilityToCheck, vulnerabilityTypeFalsePositive)) {
    return vulnerabilityTypeFalsePositive;
  } else if (hasProperty(vulnerabilityToCheck, vulnerabilityTypeSecurityException)) {
    return vulnerabilityTypeSecurityException;
  } else if (hasProperty(vulnerabilityToCheck, vulnerabilityTypeProposedClosed)) {
    // If there's a confirmed status, it's confirmed
    if (hasProperty(vulnerabilityToCheck[vulnerabilityTypeProposedClosed], 'confirmed_closed')) {
      return vulnerabilityTypeProposedClosedConfirmed;
    }

    return vulnerabilityTypeProposedClosed;
  }

  // Get the most recent history item
  const mostRecentHistoryItem = getMostRecentHistoryItem(vulnerabilityToCheck);

  if (mostRecentHistoryItem === null) {
    return null;
  }

  const historyAction = mostRecentHistoryItem.action;
  const historyStatus = mostRecentHistoryItem.status;

  if (mostRecentHistoryItem.action === 'vulnerability_pcd_resume') {
    return vulnerabilityTypeProposedClosedResume;
  } else if ((historyAction === vulnerabilityTypeFalsePositive)
    && (historyStatus === historyModel.statuses.pending)) {
    return vulnerabilityTypeFalsePositivePending;
  } else if ((historyAction === vulnerabilityTypeFalsePositive)
    && (historyStatus === historyModel.statuses.rejected)) {
    return vulnerabilityTypeFalsePositiveRejected;
  } else if ((historyAction === vulnerabilityTypeSecurityException)
    && (historyStatus === historyModel.statuses.pending)) {
    return vulnerabilityTypeSecurityExceptionPending;
  } else if ((historyAction === vulnerabilityTypeSecurityException)
    && (historyStatus === historyModel.statuses.rejected)) {
    return vulnerabilityTypeSecurityExceptionRejected;
  }

  return null;
}

/**
 * Checks if the vulnerability security exception (if it has one) expires sometime "soon"
 * @param {Object} vulnerabilityToCheck The vulnerability to check
 * @returns {Boolean} True if the security exception finishes "soon", false if not or it doesn't
 *  have an active SE
 */
function doesSecurityExceptionExprireSoon(vulnerabilityToCheck) {
  if (!hasProperty(vulnerabilityToCheck, vulnerabilityTypeSecurityException)) {
    return false;
  }

  const daysToAlertBefore = config.vulnerabilities.types.securityException.daysToAlertBeforeEnd;
  const expiryDate = moment(vulnerabilityToCheck[vulnerabilityTypeSecurityException].end_date);
  const expiryDateAlert = expiryDate.subtract(daysToAlertBefore, 'days');
  const currentDate = moment();

  return currentDate.isAfter(expiryDateAlert);
}

/**
 * Checks if the vulnerability security exception has expired
 * @param {Object} vulnerabilityToCheck The vulnerability to check
 * @returns {Boolean} True if the security exception has expired, false if not or it doesn't
 *  have an active SE
 */
function hasSecurityExceptionExprired(vulnerabilityToCheck) {
  if (!hasProperty(vulnerabilityToCheck, vulnerabilityTypeSecurityException)) {
    return false;
  }

  const expiryDate = moment(vulnerabilityToCheck[vulnerabilityTypeSecurityException].end_date);
  const currentDate = moment();

  return currentDate.isAfter(expiryDate);
}


/**
 * Checks if the vulnerability is closed or not
 * @param {Object} vulnerabilityObject The vulnerability to check
 * @returns {Boolean} True if the vulnerability is closed false otherwise
 *  have an active SE
 */
function isClosed(vulnerabilityObject) {
  if (hasProperty(vulnerabilityObject, 'false_positive')
    || (hasProperty(vulnerabilityObject, 'proposed_close_date')
      && (vulnerabilityObject.proposed_close_date.confirmed_closed === 1))) {
    return true;
  }
  return false;
}

/**
 * Get vulnerabilities of provided vulnerability Ids in Array for the given organisation
 * @param {Number} organisationId - ID of the organisation to get the vulnerabilities for
 * @param {Array} vulnerabilityIds - Array of vulnerability Id's to get the details
 * @return {Object} Mongo cursor
 */
const getVulnerabiltiesByIds = (organisationId, vulnerabilityIds) => {
  const mongoVulnerabilities = [];
  _.each(vulnerabilityIds, (vulnerabilityId) => {
    mongoVulnerabilities.push(new MongoObjectId(vulnerabilityId));
  });
  const queryParameters = { _id: { $in: mongoVulnerabilities } };
  return mongo.find(organisationId, config.mongo.tables.vulnerabilities, queryParameters);
};

/**
 * Converts the severity number to the number of days
 * @param {Object} slaDaySettings The SLA settings for the organisation
 * @param {Number} severityNumber The number for the severity i.e. 0-4
 * @returns {Number} The number of SLA days for the given severity
 */
function getSlaDaysBySeverityNumber(slaDaySettings, severityNumber) {
  const severityName = severities[severityNumber].toLowerCase();
  return slaDaySettings[severityName];
}

/**
 * Updates the deleted scans in reports model with deleted flag
 * @param {Number} organisationId - ID for the organisation to query
 * @param {Object} queryParameters - Additional query parameters to be added
 * @param {Object[]} deletedScans - List of deleted nessus scan ids
 */
const updateDeletedScans = async (organisationId, queryParameters = {}, deletedScans = []) => {
  const supportedTypes = await servicesHelper.getServicesSlugs(true);

  if (supportedTypes && supportedTypes.VM && supportedTypes.VM.short) {
    // update deleted scans
    let scanCollectionPromise = mongo.collection(organisationId,
      config.mongo.tables.scans);

    if (scanCollectionPromise) {
      scanCollectionPromise.then((mongoScanCollection) => {
        if (mongoScanCollection) {
          let queryObject = {
            $or: [
              {
                'is_deleted': { $exists: false }
              },
              {
                'is_deleted': false
              }
            ],
            'tenable_scan_id': queryParameters.scan_id
          };

          //This will update the deleted scans in mongo db
          mongoScanCollection.updateMany(queryObject, { $set: { 'is_deleted': true } });

          //This will revert the deleted status in mongo db if the scan is moved out of trash in nessus
          mongo.find(organisationId, config.mongo.tables.scans, { 'is_deleted': true }, { 'tenable_scan_id': 1 }).then(function (scansList) {
            scansList.toArray(function (err, scanArray) {
              let undeletedScans = [];

              _.each(scanArray, function (scan) {
                if (deletedScans.indexOf(scan.tenable_scan_id) < 0) {
                  undeletedScans.push(scan._id);
                }
              });

              mongoScanCollection.updateMany({ _id: { $in: undeletedScans } }, { $set: { 'is_deleted': false } });
            });
          });
        }
      });
    }

    let searchParameters = {
      attributes: ['organization_id', 'credentials'],
      include: [{
        model: models.Service,
        where: {
          short: _.toUpper(supportedTypes.VM.short)
        },
        attributes: ['id']
      }]
    };

    models.OrgService.findAll(searchParameters).then(function (result) {
      let organisationList = result.map(function (organisation) {
        return {
          organisationId: organisation.dataValues.organization_id
        };
      });

      let groupedOrganisation = _.groupBy(organisationList, 'organisationId');

      if (groupedOrganisation[organisationId] && groupedOrganisation[organisationId].length > 0) {
        let collectionPromise = mongo.collection(organisationId, config.mongo.tables.reports);

        if (collectionPromise) {
          collectionPromise.then((mongoCollection) => {
            if (mongoCollection) {
              mongoCollection.updateMany(queryParameters, { $set: { 'is_nessus_deleted': true } });
            }
          });
        }
      }
    });
  } else {
    throw new Error(constantErrors.organizationService.supportedTypesNotAvailable);
  }
}

function formatReportFields(reportsWithVulnerabilities) {
  let gropuedByReportId = _.groupBy(reportsWithVulnerabilities, "_id");
  let reportObjects = [];

  _.forOwn(gropuedByReportId, function (reportObj) {
    let reportObject = {
      _id: reportObj[0]._id,
      report_name: reportObj[0].report_name,
      utc_time: reportObj[0].utc_time,
      vulnerabilities: []
    };

    _.each(reportObj, function (reportsWithVulnerability) {
      reportObject.vulnerabilities.push(reportsWithVulnerability.vulnerabilities);
    });

    reportObjects.push(reportObject);
  });

  return reportObjects;
}

const getIterationCount = (totalCount) => {
  let countDifference = totalCount / dashboardLimit;
  countDifference = countDifference.toString();
  let iterationCount = 0;

  if (countDifference.indexOf('.') > -1) {
    let decimalValue = countDifference.split('.')[1];
    iterationCount = countDifference.split('.')[0];

    if (parseInt(decimalValue) > 0) {
      iterationCount++;
    }
  }

  return iterationCount;
};

const getReportsForOrg = async (db = {}, iterationCount, queryParameters, populate, reports = [], skipCount = 0) => {
  try {
    db.model('vulnerabilities', vulnModel);
    let reportsList = await db.model('reports', reportsModel).find(queryParameters, 'utc_time scan_id vulnerabilities').populate(populate).limit(dashboardLimit).skip(skipCount).lean();

    if (reportsList && reportsList.length > 0) {
      reports = reports.concat(reportsList);
    }

    iterationCount--;

    if (iterationCount > 0) {
      return await getReportsForOrg(db, iterationCount, queryParameters, populate, reports, reports.length)
    } else {
      return reports;
    }
  } catch (error) {
    throw error;
  }
};

const getVulnerabilitiesByOrganization = async (url, queryParameters = {}, match = null) => {
  try {
    let populate = { path: "vulnerabilities", select: "count severity" };

    if (match) {
      populate.match = match;
    }

    let dbName = url.split('/');
    let db = mongoose.connection.useDb(dbName[dbName.length - 1]);
    let totalCount = await db.model('reports', reportsModel).countDocuments(queryParameters);
    let iterationCount = totalCount > dashboardLimit ? getIterationCount(totalCount) : 1;
    let reports = await getReportsForOrg(db, iterationCount, queryParameters, populate);

    return reports;
  } catch (error) {
    throw error;
  }
}


module.exports = {
  vulnerability,
  getPendingForOrganisation,
  getVulnerabiltiesByReports,
  sortVulnerabilityHistory,
  isClosed,
  getVulnerabiltiesByIds,
  updateDeletedScans,
  removeExpiredSecurityException,
  formatReportFields,
  getVulnerabiltiesForCharts,
  getVulnerabilitiesByOrganization
};

module.exports.vulnerabilityTypeProposedClosed = vulnerabilityTypeProposedClosed;
module.exports.vulnerabilityTypeProposedClosedConfirmed = vulnerabilityTypeProposedClosedConfirmed;
module.exports.vulnerabilityTypeProposedClosedResume = vulnerabilityTypeProposedClosedResume;
module.exports.vulnerabilityTypeFalsePositive = vulnerabilityTypeFalsePositive;
module.exports.vulnerabilityTypeFalsePositivePending = vulnerabilityTypeFalsePositivePending;
module.exports.vulnerabilityTypeFalsePositiveRejected = vulnerabilityTypeFalsePositiveRejected;
module.exports.vulnerabilityTypeSecurityException = vulnerabilityTypeSecurityException;
module.exports.vulnerabilityTypeSecurityExceptionPending =
  vulnerabilityTypeSecurityExceptionPending;
module.exports.vulnerabilityTypeSecurityExceptionRejected =
  vulnerabilityTypeSecurityExceptionRejected;
module.exports.doesSecurityExceptionExprireSoon = doesSecurityExceptionExprireSoon;
module.exports.hasSecurityExceptionExprired = hasSecurityExceptionExprired;
module.exports.getVulnerabilityType = getVulnerabilityType;
module.exports.getMostRecentHistoryItem = getMostRecentHistoryItem;
module.exports.getSlaDaysBySeverityNumber = getSlaDaysBySeverityNumber;
module.exports.buildVulnerabilityQuery = buildVulnerabilityQuery;
