const partialName = 'summary-vulnerability-types';
const reportConfigurableHelper = require('../../../helpers/report-configurable');
const vulnerabilityModel = require('../../../models/vulnerability');
const handlebars = require('handlebars');
const _ = require('lodash');
const config = require('config');
const Promise = require('bluebird');

/**
 * Prepare data before populating into PDF report
 * @param {Object} data - The data to prepare
 * @return {Object} Prepared data
 */
const build = (organisationId, reportIds) => {
  // Register the partial
  handlebars.registerPartial(partialName,
    reportConfigurableHelper.fsReadBlockTemplate(partialName));

  return vulnerabilityModel.getVulnerabiltiesByReports(organisationId, reportIds).then(
    function (reportsCursor) {
      return reportsCursor.toArray().then(function (reportsWithVulnerabilities) {
        reportsWithVulnerabilities = vulnerabilityModel.formatReportFields(reportsWithVulnerabilities);
        
        return {
          reports: reportsWithVulnerabilities
        };
      }, function (error) {
        return Promise.reject(error);
      });
    }, function (error) {
      return Promise.reject(error);
    });
};


/**
 * Prepares the data from the above request if required
 * @param {Mixed} values The reports and vulnerabilities from the `build`
 *  method above
 */
const prepare = (values) => {
/**
 * adds id to array only if its unique
 * @param {Array} array array containing muliple ids
 * @param {Array} id id to be added
 */
  const addUniqueIDToArray = (array, id) => {
    if (!_.some(array, id)) {
      array.push(id);
    }
  };

  const summaryArray = {
    falsePositive: {
      pending: [],
      accepted: [],
      rejected: []
    },
    securityExceptions: {
      pending: [],
      accepted: [],
      rejected: [],
      expiringSoon: [],
      expired: []
    },
    proposedClosed: {
      proposed: [],
      confirmed: [],
      resumed: []
    }
  };

  _.each(values.reports, function (report) {
    _.each(report.vulnerabilities, function (vulnerability) {
      const vulnerabilityType = vulnerabilityModel.getVulnerabilityType(vulnerability);
      const id = vulnerability._id;

      if (vulnerabilityType === vulnerabilityModel.vulnerabilityTypeProposedClosed) {
        addUniqueIDToArray(summaryArray.proposedClosed.proposed, id);
      } else if (vulnerabilityType ===
              vulnerabilityModel.vulnerabilityTypeProposedClosedConfirmed) {
        addUniqueIDToArray(summaryArray.proposedClosed.confirmed, id);
      } else if (vulnerabilityType === vulnerabilityModel.vulnerabilityTypeProposedClosedResume) {
        addUniqueIDToArray(summaryArray.proposedClosed.resumed, id);
      } else if (vulnerabilityType === vulnerabilityModel.vulnerabilityTypeFalsePositive) {
        addUniqueIDToArray(summaryArray.falsePositive.accepted, id);
      } else if (vulnerabilityType === vulnerabilityModel.vulnerabilityTypeFalsePositivePending) {
        addUniqueIDToArray(summaryArray.falsePositive.pending, id);
      } else if (vulnerabilityType === vulnerabilityModel.vulnerabilityTypeFalsePositiveRejected) {
        addUniqueIDToArray(summaryArray.falsePositive.rejected, id);
      } else if (vulnerabilityType ===
              vulnerabilityModel.vulnerabilityTypeSecurityExceptionPending) {
        addUniqueIDToArray(summaryArray.securityExceptions.pending, id);
      } else if (vulnerabilityType ===
              vulnerabilityModel.vulnerabilityTypeSecurityExceptionRejected) {
        addUniqueIDToArray(summaryArray.securityExceptions.rejected, id);
      } else if (vulnerabilityType === vulnerabilityModel.vulnerabilityTypeSecurityException) {
        addUniqueIDToArray(summaryArray.securityExceptions.accepted, id);

        // Check if the security exception is expriring soon
        if (vulnerabilityModel.hasSecurityExceptionExprired(vulnerability)) {
          addUniqueIDToArray(summaryArray.securityExceptions.expired, id);
        } else if (vulnerabilityModel.doesSecurityExceptionExprireSoon(vulnerability)) {
          addUniqueIDToArray(summaryArray.securityExceptions.expiringSoon, id);
        }
      }
    });
  });
  // Update count of Proposed Close Dates based on array size
  summaryArray.proposedClosed.proposed = summaryArray.proposedClosed.proposed.length;
  summaryArray.proposedClosed.confirmed = summaryArray.proposedClosed.confirmed.length;
  summaryArray.proposedClosed.resumed = summaryArray.proposedClosed.resumed.length;

  // Update count of False Positives based on array size
  summaryArray.falsePositive.pending = summaryArray.falsePositive.pending.length;
  summaryArray.falsePositive.accepted = summaryArray.falsePositive.accepted.length;
  summaryArray.falsePositive.rejected = summaryArray.falsePositive.rejected.length;

  // Update count of Security Exceptions based on array size
  summaryArray.securityExceptions.pending = summaryArray.securityExceptions.pending.length;
  summaryArray.securityExceptions.accepted = summaryArray.securityExceptions.accepted.length;
  summaryArray.securityExceptions.rejected = summaryArray.securityExceptions.rejected.length;
  summaryArray.securityExceptions.expiringSoon =
  summaryArray.securityExceptions.expiringSoon.length;
  summaryArray.securityExceptions.expired = summaryArray.securityExceptions.expired.length;

  // Add the days until SE expires
  summaryArray.seDaysUntilExpired =
          config.vulnerabilities.types.securityException.daysToAlertBeforeEnd;

  return summaryArray;
};

module.exports.build = build;
module.exports.partialName = partialName;
module.exports.prepare = prepare;
